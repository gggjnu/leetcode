第八章 贪心算法 part05
# 56. 合并区间  
本题也是重叠区间问题，如果昨天三道都吸收的话，本题就容易理解了。

https://programmercarl.com/0056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html  
- 按左端点排序区间
- 初始化当前重叠片段起点、终点为第一个区间左端，遍历区间
- 如果i区间左端<=终点，则终点更新i为区间终点和终点的较大值；否则结果收集此时的重叠片段起点、终点，起点、终点更新为i区间的左端、右端
```Python
def merge(self, intervals: List[List[int]]) -> List[List[int]]:
    
    intervals.sort(key=lambda x:x[0])
    start,end = intervals[0][0],intervals[0][0]
    result = []
    for i in intervals:
        # 如果当前区间和上一去卷重叠
        if i[0] <= end:
            end = max(end,i[1])
        # 如果不重叠
        else:
            result.append([start,end])
            start,end = i[0],i[1]
    # 最后一个重叠区间，手动收集
    result.append([start,end])
    return result
```

# 738.单调递增的数字 
https://programmercarl.com/0738.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html  
- 求最大，所以从个位开始向前检查。每个数字想象成一个环形数字圈：如果前一位数比当前位数大，那最近满足要求的**当前位数字以及右边的数字只能是往回递减拨到9**，前一位数往回拨一位；否则继续向前检查其他位的数字 
- n转变为列表方便遍历与修改

```Python
def monotoneIncreasingDigits(self, n: int) -> int:
    # 暴力超时
    
    listnum = list(str(n))
    for i in range(len(listnum)-1,0,-1): # 0取不到，确保下标不越界
        # 如果前一位数大于当前位数
        if listnum[i-1] > listnum[i]:
            listnum[i-1] = str(int(listnum[i-1])-1) # 前一位数减1
            for j in range(i,len(listnum)): # 当前位数和右边位数的数字都变成9
                listnum[j] = '9'
        # 如果前一位数和当前位数符合要求
        else: pass
    return int(''.join(listnum))
```

# 968.监控二叉树 （可跳过）

本题是贪心和二叉树的一个结合，比较难，一刷大家就跳过吧。 
https://programmercarl.com/0968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html  
 总结 

总结
可以看看贪心算法的总结，贪心本来就没啥规律，能写出个总结篇真的不容易了。 
https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E7%AF%87.html 

