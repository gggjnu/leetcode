第九章 动态规划part02

今天开始逐渐有 dp的感觉了，前 两题 不同路径，可以好好研究一下，适合进阶

 详细布置 

# 62.不同路径 

本题大家掌握动态规划的方法就可以。 数论方法 有点非主流，很难想到。 

https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html  
视频讲解：https://www.bilibili.com/video/BV1ve4y1x7Eu

- 注意：从各自走到格子，不是从坐标点走到坐标点。mn区域初始化mn大小的数组
- dp数组表示走到这个格子的路径数量，等于左边格子dp+上面格子dp。```dp[i][j] = dp[i-1][j] +dp[j-1][i]```


# 63. 不同路径 II 

https://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.html  
视频讲解：https://www.bilibili.com/video/BV1Ld4y1k7c6           

- 左边上边不是障碍，就照常等于左边上边dp值相加
- 如果左边有障碍，就等于上边dp，因为只能从上边过来这里；同理如果上边有障碍，就等于左边dp;如果上边下边都有，dp为0
- **如果是障碍，dp为0**
- 通用递推公式```dp[i][j] = dp[i-1][j] +dp[j-1][i]```
```Python
def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
    
    m,n = len(obstacleGrid),len(obstacleGrid[0])
    route_cnt = [[0]*n for _ in range(m)]
    # 上边、左边初始化
    route_cnt[0] = [1 if i == 0 else 0 for i in obstacleGrid[0] ]
    if 1 in obstacleGrid[0]:
        route_cnt[0][obstacleGrid[0].index(1):] = [0] * (n-obstacleGrid[0].index(1))
    for r in range(m):
        if obstacleGrid[r][0] != 0:
            flag = r
            break # 初始化为0，所以障碍及后面不用管了默认是0
        else: 
            route_cnt[r][0] = 1
    
    # 递推
    for r in range(1,m):
        for c in range(1,n):
            # 如果是障碍
            if obstacleGrid[r][c] == 1: route_cnt[r][c] = 0
            # 如果不是障碍，上、左相加。如果上、左有障碍也已经更新为0了，所以不用考虑上、左是不是障碍
            else:
                route_cnt[r][c] = route_cnt[r-1][c] + route_cnt[r][c-1]
    return route_cnt[m-1][n-1] 
```


# 343. 整数拆分 （可跳过）
本题思路并不容易想，一刷建议可以跳过。如果学有余力，可以看视频理解一波。

https://programmercarl.com/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html   
视频讲解：https://www.bilibili.com/video/BV1Mg411q7YJ

- dp[i]表示i这个数拆分后相乘的最大乘积
- dp的0-2可以初始化。再往后，求n的拆分最大乘积可以看做拆分成两个数、拆分成两个数以上的最大值。拆分的数字是1到n-i都遍历一遍，**拆出来的数字要么是一个数，要么预示着它本身的拆分最大乘积**，两种理解都乘上剩余部分的那个数字就是要求的全部乘积
```Python
def integerBreak(self, n: int) -> int:
    
    max_product = [0] * (n+1)
    max_product[0],max_product[1],max_product[2] = 0,1,1
    for i in range(3,n+1): # 构建dp的每一个结果
        for j in range(1,i):  # 每构建一个dp元素，都得从头遍历一遍到目前的i，找出所有的可能
            max_product[i] = max(max_product[i],  j*(i-j),  max_product[j]*(i-j))
    return max_product[n]
```


# 96. 不同的二叉搜索树 （可跳过）
本题思路并不容易想，一刷建议可以跳过。 如果学有余力，可以看视频理解一波。

https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html   
视频讲解：https://www.bilibili.com/video/BV1eK411o7QA 

- 动态规划解决二叉树问题就这一道
- 分类讨论，子问题递推到最前面的情况.dp[i]表示i个节点的二叉搜索树的多少棵。dp[0] = 1,dp[1]=1,dp[2]=2

```
dp[3] 
= 1是根节点 + 2是根节点 + 3是根节点 
= 左边0个节点的树数量* 右边放2个的树数量 + 左边放1个节点* 右边放1个节点 + 左边放2个节点*右边放0个节点
=dp[0]*dp[2] + dp[1]*dp[1] + dp[2]* dp[0]
```
```Python
def numTrees(self, n: int) -> int:
    if n<2: return 1
    tree_cnt = [0]*(n+1)
    tree_cnt[0],tree_cnt[1],tree_cnt[2] = 1,1,2 # 注意0个节点的树也算1种放法
    for i in range(3,n+1):
        for j in range(i):
            tree_cnt[i] += tree_cnt[j]*tree_cnt[(i-1)-j] 
    return tree_cnt[n]
```
