第九章 动态规划part04

# 1049. 最后一块石头的重量 II 

本题就和 昨天的 416. 分割等和子集 很像了，可以尝试先自己思考做一做。 
视频讲解：https://www.bilibili.com/video/BV14M411C7oV 
https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html  
- 逻辑：为了剩余最少，每次选两块石头都要尽量接近，等价于选出两堆和尽量接近的石头，等价于选出一堆和尽量接近sum//2的石头
- 求背包容量为sum//2装数字的最大价值dp[-1][sum//2]（最大和），这个和就是第一堆石头的和，第二堆是sum-dp[-1][sum//2],结果是两堆之差abs(sum-dp[-1][sum//2] - dp[-1][sum//2] )
```py
def lastStoneWeightII(self, stones: List[int]) -> int:
    target = sum(stones)//2 # 背包容量
    # dp初始化
    half_stones = [0]*(target+1)
    for j in range(stones[0],target+1): # 第一行可以不用单独初始
        half_stones[j] = stones[0]
    # 一维递推
    for i in range(1,len(stones)):
        for j in range(target,stones[i]-1,-1):
            half_stones[j] = max(half_stones[j],half_stones[j-stones[i]]+stones[i])
    return abs(sum(stones) - half_stones[-1] - half_stones[-1])
```
# 494. 目标和 
大家重点理解 递推公式：dp[j] += dp[j - nums[i]]，这个公式后面的提问 我们还会用到。  
视频讲解：https://www.bilibili.com/video/BV1o8411j73x
https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html  

- 正数部分和为x，负数部分和绝对值为y，原数字和为sum。
$$x-y=target$$
$$x+y=sum$$
$$x = (target+sum)/2$$
- 求容量为x的背包有几种装法
- dp[i][j]表示纳入考虑i数字及其之前的数字时，恰好装满j容量背包的装法总数。dp第一列初始为0，表示装满容量0背包的装法只有1种就是不装
```
递推：当背包容量是j时，拿i下标的数字过来考虑

如果清空背包都放不下：当无事发生，延续上一行的总装法（dp[i-1][j]）
如果清空背包能放下：总装法=dp[i-1][j] + dp[i-1][j-nums[i]]
- 要么维持背包，不考虑这件物品，装法数为（dp[i-1][j]）
- 要么清空背包，先放这件物品,再在缝隙处放入一个背包，装法总数为历史记录中这个缝隙背包的总装法（dp[i-1][j-nums[i]]）
```

```py
def findTargetSumWays(self, nums: List[int], target: int) -> int:
    # 回溯超时
    total_sum = sum(nums)  # 计算nums的总和
    if abs(target) > total_sum:
        return 0  # 此时没有方案
    if (target + total_sum) % 2 == 1:
        return 0  # 此时没有方案
    target_sum = (target + total_sum) // 2  # 目标和
    dp = [0] * (target_sum + 1)  # 创建动态规划数组，初始化为0
    dp[0] = 1  # 当目标和为0时，只有一种方案，即什么都不选
    for num in nums:
        for j in range(target_sum, num - 1, -1): # 如果当前数字时0，本轮相当于将上一轮的装法翻倍，效果是考虑了这个0之后，装满目标容量的方法=之前的方法*2，实际含义是在上一轮得到的所有方法dp[i-1][target_sum]中,每个方法中添加一个+0都是一个新方法，合起来是原来的2倍多
            dp[j] += dp[j - num]  # 状态转移方程，累加不同选择方式的数量
    return dp[target_sum]  # 返回达到目标和的方案数
```



# 474.一和零  
通过这道题目，大家先粗略了解， 01背包，完全背包，多重背包的区别，不过不用细扣，因为后面 对于 完全背包，多重背包 还有单独讲解。
视频讲解：https://www.bilibili.com/video/BV1rW4y1x7ZQ 
https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html  

- dp[i][j]: 最多含有i个0和j个1的字符串组合的最大字符串个数
- i和j都是类似“重量”的物品属性，和物品紧密相关，所以为了不覆盖历史字符串计数，均从后往前遍历




