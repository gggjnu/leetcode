第四章 字符串part02
今日任务 

●151.翻转字符串里的单词
●卡码网：55.右旋转字符串
●28. 实现 strStr()
●459.重复的子字符串
●字符串总结 
●双指针回顾 

 详细布置  

# 151.翻转字符串里的单词 

建议：这道题目基本把 刚刚做过的字符串操作 都覆盖了，不过就算知道解题思路，本题代码并不容易写，要多练一练。 

题目链接/文章讲解/视频讲解：https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html  

```Python
def reverseWords(self, s: str) -> str:
    return " ".join(s.strip().split()[::-1])
```

# 卡码网：55.右旋转字符串 

建议：题解中的解法如果没接触过的话，应该会想不到

题目链接/文章讲解： 

https://programmercarl.com/kamacoder/0055.%E5%8F%B3%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2.html

# 28. 实现 strStr()  （在文本串中找模式串）

因为KMP算法很难，大家别奢求 一次就把kmp全理解了，大家刚学KMP一定会有各种各样的疑问，先留着，别期望立刻啃明白，第一遍了解大概思路，二刷的时候，再看KMP会 好懂很多。

或者说大家可以放弃一刷可以不看KMP，今天来回顾一下之前的算法题目就可以。

因为大家 算法能力还没到，细扣 很难的算法，会把自己绕进去，就算别人给解释，只会激发出更多的问题和疑惑。所以大家先了解大体过程，知道这么回事， 等自己有 算法基础和思维了，在看多看几遍视频，慢慢就理解了。

题目链接/文章讲解/视频讲解：https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html 

## KMP（了解即可）
- 前缀表目的：提示当匹配首次出现不匹配时，要从```模式串```的哪个位置开始重新匹配。由于模式串中间可能会存在模式串的开头子串，所以当出现不匹配时，可能前面走过的一部分```文本串```会是模式串的开头子串

- 前缀表含义：下标i存放模式串截止到i处（含i）子串的最长相同前后缀长度。例如abaa的最长相同前后缀长度为1，aabaa为2

```Python
def strStr(self, haystack: str, needle: str) -> int:
    # kmp：i遍历文本串，最终指向匹配好全部模式串的下一位。j指向模式串中要匹配的字符。核心思想是遇到不同，尽量不浪费j走过的路，也不浪费紧挨着i前面可能存在的needle前缀
    # next数组：告诉我们当出现不匹配时，j下一步要回退到什么地方。next数组存放needle截断子串的最长相同前后缀的长度。next数组的实现本身也是一个类似本题的过程，实现过程中的i是截断子串的末位，j是截断子串前缀的末位，也是该子串的最长相同前后缀的长度
    # 主过程：三步的顺序不能调换
    
    # 获取next数组
    def get_next(needle):
        next_list = [0]*len(needle)
        j = 0
        next_list[0] = 0
        for i in range(1,len(needle)): # next首位已经定义，故从下标1开始
            # ij对应字符不同时，不断回退到j前一位对应的最长前后缀长度处，直到相同。
            # 首轮j要放过，因为没有j-1
            while j>0 and needle[i] != needle[j]:
                j = next_list[j-1]
            # ij对应字符相同时，最长前后缀+1
            if needle[i] == needle[j]:
                j += 1
            # 每一轮i都更新next
            next_list[i] = j
        return next_list
    
    # 主过程（）
    next_list = get_next(needle)
    j = 0 # 指向needle字符
    for i in range(len(haystack)):

        # 当ij对应字符不等时，不断回退到j前一位对应的最长前后缀长度处，直到相同。
        while j>0 and haystack[i] != needle[j]:
            j = next_list[j-1]
        
        # 当ij对应字符相等时，j后移，i自动在下一轮后移
        if  haystack[i] == needle[j]:
            j += 1

        # j等于needle长度说明完成匹配
        if j == len(needle): return i-j+1
    return -1
```

## python内置函数
- 字符串.find(): 返回是否存在子串，是返回起始下标，否-1
- 字符串.index(): 返回子串在字符串中开始的下标，**无则报错**

# 459.重复的子字符串  （本题可以跳过）

本题算是KMP算法的一个应用，不过 对KMP了解不够熟练的话，理解本题就难很多。 
我的建议是 KMP和本题，一刷的时候 ，可以适当放过，了解怎么回事就行，二刷的时候再来硬啃

题目链接/文章讲解/视频讲解：https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html 

## 暴力
- 在字符串的前半部分中，依次递增一位取子串，如果子串在后面出现且子串能拼成原字符串串，则符合题意。因为拼成字符串的子串不可能大于长度一半，所以大于一半长度的子串可以不用考虑，考虑前半部分就行
```Python
class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:

        for i in range(1,len(s)//2+1):
            sub_s = s[:i]
            if s[i:].find and sub_s * (len(s)//len(sub_s)) == s:
                return True
        return False
```
## 移动循环
- 移动循环法：如果符合题意的话，每次把最后一个字符移到首位，移动子串长度次后，会重新变成原字符串（相当于把最后一个子串放到开头）；如果不符合题意，只有在移动原字符串长度次后（回到原来的样子），才会变成原字符串
- 为了避免这种无用的环绕，可以创建一个新的字符串 str，它等于原来的字符串 S 再加上 S 自身，这样其实就包含了所有移动的字符串。比如字符串：S = acd，那么 str = S + S = acdacd，acd 移动的可能：dac、cda。其实都包含在了 str 中（从右到左的长度为3滑动窗口）。
- 如果不符题意，则只有在首、尾滑窗才能找到原字符串，如果符合题意，则在非首尾窗也能找到原字符串。所以把首尾窗破坏、中间窗保留，也就是把首字符、尾字符去掉后，如果还能找到原字符串，则符合题意
```Python
def repeatedSubstringPattern(self, s: str) -> bool:
    return (s+s)[1:-1].find(s) != -1
```

# 字符串总结 

比较简单，大家读一遍就行 

题目链接/文章讲解：https://programmercarl.com/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93.html 

# 双指针回顾(必看)

此时我们已经做过10道双指针的题目了，来一起回顾一下，大家自己也总结一下双指针的心得 

文章讲解：https://programmercarl.com/%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93.html 
  
