第八章 贪心算法 part04 

今天的三道题目，都算是 重叠区间 问题，大家可以好好感受一下。 都属于那种看起来好复杂，但一看贪心解法，惊呼：这么巧妙！  

这种题还是属于那种，做过了也就会了，没做过就很难想出来。

不过大家把如下三题做了之后， 重叠区间 基本上差不多了 

# 452. 用最少数量的箭引爆气球

https://programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html  

- 灵神解法更简洁
- 气球**按照右端点排序**，每次射箭在当前气球的最右侧，如果不重叠，射当前气球，射箭数量+1，同时记录本次射箭位置；如果重叠，当前气球不追加射箭（被上一一次射箭射中了），射箭位置更新为当前气球的末端

```Python
 def findMinArrowShots(self, points: List[List[int]]) -> int:
    
    points.sort(key=lambda x: x[1]) # 原地修改
    result = 0
    last_arrow = -float('inf') # 记录上一支箭的位置
    for start,end in points:
        # 如果不重叠，表示要增加一支箭射在当前气球的最右端
        if start > last_arrow:
            result += 1
            last_arrow = end
        # 如果重叠，跳过当前气球，表示气球被引爆
        else:
            pass
    return result
```




# 435. 无重叠区间 

https://programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html  
- 按照左端点排序，逐个比较，如果出现重叠的，就把末端靠后的那个区间删了（末端越靠后，更有可能和别的区间重叠，所以优先删除），删除次数加一;如果没有重叠，更新用于比较的右边界为当前区间的右边界
- 
```Python
def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        
        intervals.sort(key=lambda x:x[0])
        result = 0
        # 第一个区间直接拿来比较，从第二个区间开始遍历
        last_end = intervals[0][1]
        for i in range(1,len(intervals)):
            # 如果重叠，就扔掉末端靠后的那个
            if intervals[i][0] < last_end:
                result += 1 
                last_end = min(last_end,intervals[i][1])
            # 如果不重叠，更新lastend
            else:
                last_end = intervals[i][1]
        return result
```
# 763.划分字母区间 

https://programmercarl.com/0763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html  

- **同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段**。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。

- 从左到右遍历字符串，遍历的同时维护当前片段的开始下标 start 和结束下标 end，初始时 start=end=0。对于每个访问到的字母 c，得到当前字母的最后一次出现的下标位置 endc，比较其与当前片段的结束下标end取较大者， end=max(end,endc)，原因是如果现在没到end位置，说明当前这个字母也是要被收纳进来的，就要考虑这个字母是否扩大了当前片段的范围。

- 更新完要立即判断这时候i是不是走到了当下最新的end，是则当前片段的下标范围是 [start,end]，长度为 end−start+1，将当前片段的长度添加到返回值，然后令 start=end+1，继续寻找下一个片段。
- 语法：注意循环迭代的代称(i等命名)不能和其他变量名重复
```Python
def partitionLabels(self, s: str) -> List[int]:
    # 获取每个字母的最后下标位置，逐个更新字典值
    last_loc = {}
    for i,ch in enumerate(s): 
        last_loc[ch] = i 

    result = []
    start,end = 0,0 # 当前片段的起始位置
    # 遍历s，动态更新当前片段结束为止
    for i in range(len(s)):
        end = max(end,last_loc[s[i]]) # 更新片段结束位置
        if end == i: # 如果来到了当前片段的结束位置，收集结果、更新起始位置
            result.append(end-start+1)
            start = i+1
    return result
```

 

