第九章 动态规划part06
# 322. 零钱兑换  

如果求组合数就是外层for循环遍历物品，内层for遍历背包。
如果求排列数就是外层for遍历背包，内层for循环遍历物品。

这句话结合本题 大家要好好理解。
视频讲解：https://www.bilibili.com/video/BV14K411R7yv
https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html  
- 完全背包。dp[i][j]:考虑i硬币以及之前的硬币，凑成j金额的最少硬币数
- 递推：如果j能装得下该类硬币，取不多添加这一枚硬币的历史最少硬币数（dp[i-1][j]）和空出这一枚硬币的地方放它再放本轮更新过的缝隙背包（dp[i][j-coins[i]]+1）的最小值;装不下就用历史最少dp[i-1][j]
- 初始化,和为0需要0枚硬币。因为递推里面自带1，所以当j==coins[i]时需要历史最新缝隙背包dp[i][0]为0
```py
def coinChange(self, coins: List[int], amount: int) -> int:
    
    min_cnt = [float('inf')]*(amount+1) # 取小，初始化为正无穷
    min_cnt[0] = 0
    # 一维递推。组合和排列的币数一样，组合即可，外层遍历物品
    for i in range(len(coins)):
        for j in range(coins[i],amount+1):
            min_cnt[j] = min(min_cnt[j],min_cnt[j-coins[i]]+1)
    print(min_cnt)
    return min_cnt[-1] if min_cnt[-1] != float('inf') else -1
```

# 279.完全平方数  
本题 和 [322. 零钱兑换](#322-零钱兑换) 基本是一样的，大家先自己尝试做一做 
视频讲解：https://www.bilibili.com/video/BV12P411T7Br
https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html  
- 先求备选数字的边界
```py
def numSquares(self, n: int) -> int:
    # 完全背包

    max_num =  int(pow(n,0.5))
    # 初始化
    min_cnt = [float('inf')]*(n+1)
    min_cnt[0] = 0
    # 递推
    for i in range(1,max_num+1):
        for j in range(i**2,n+1):
            min_cnt[j] = min(min_cnt[j],min_cnt[j-i**2]+1)
    return min_cnt[-1]
```
 

# 139.单词拆分 
视频讲解：https://www.bilibili.com/video/BV1pd4y147Rh
https://programmercarl.com/0139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html
- 完全背包（需要考虑选词顺序，是求排列）。s能否被worddict填满
- dp[j]: 从前面截取**长度为j**的s子字符串，能否被worddict中的单词填满
- 递推：j相当于是本轮截取的终点位置，起始位置i是遍历0到j。只有s[:i]能被单词填满且s[i:j]也在单词里才能说明前面长度为j的子字符串能被worddict填满。
$$dp[j] = dp[i] and s[i:j] in worddict$$
- 注意一旦dp[j]被更新为True，要跳出，防止在本轮被更新为False。例如本轮检验s[:5]='catab',字典=['cat','ab'],当i==3,dp[5]=True,如果不跳出继续遍历i的话，当i==4,dp[5]重置为False,不符合dp的含义了。
```py
def wordBreak(self, s: str, wordDict: List[str]) -> bool:

    # 初始化
    if_filled = [False]*(len(s)+1)
    if_filled[0] = True # 为了能够启动递推设置为True
    # 递推
    for j in range(1,len(s)+1): # 先遍历背包容量
        for i in range(j): # 在本轮子串s[:j]中尝试所有的可能,一旦有能凑成的马上跳出,防止被更新为False
            if_filled[j] = if_filled[i] and s[i:j] in wordDict
            if if_filled[j]: break
    return if_filled[-1]

```

# 关于多重背包，你该了解这些！ 
https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.html
- 多重背包和0-1背包的区别：每次考虑空出该件物品空间的时候，要考虑空出1件、2件、···、最大可取用件数，**在0-1背包的基础上多一轮遍历该物品所有可放入数量的情况**
- 完全背包和0-1背包的区别：每次考虑缝隙背包的时候，要考虑本轮的最新更新的缝隙背包，所以是**顺序遍历背包容量更新**，而0-1只能采取不考虑该件物品的缝隙背包只能用上一轮的，所以为了避免覆盖要**倒序遍历背包容量来更新**

```py
# 多重背包。在0-1背包的基础上多一轮遍历该物品能取的数量
nm = input().split() # m物品数量，n背包最大容量
n,m = int(nm[0]),int(nm[1])
weight = [int(i) for i in input().split()]
value = [int(i) for i in input().split()]
amount = [int(i) for i in input().split()]

# 初始化
max_value = [0]*(n+1)
# 一维递推
for i in range(m): # 对于每一类物品
    for j in range(n,weight[i]-1,-1): # 对于每个容量倒序遍历，只更新至少能放得下1件物品i的那些背包
        for k in range(1,amount[i]+1): # 依次考虑空出k个物品i的空间
            if k*weight[i] <= j: # 如果能放得下k件物品i，就用缝隙背包更新
                max_value[j] = max(max_value[j],max_value[j-k*weight[i]]+k*value[i])
            else: break # 再多的物品i已经放不下了，跳出
print(max_value[-1])
```

 背包问题总结篇！ 
https://programmercarl.com/%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93%E7%AF%87.html  


