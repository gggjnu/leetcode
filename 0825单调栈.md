第十章 单调栈part01

# 739. 每日温度 

今天正式开始单调栈，这是单调栈一篇扫盲题目，也是经典题。

大家可以读题，思考暴力的解法，然后在看单调栈的解法。 就能感受出单调栈的巧妙

https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html  
```py
def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
    # 就近匹配，用栈.
     
    result = [0]*len(temperatures)
    stack = []
    for i,t_cur in enumerate(temperatures):
        while stack and t_cur > stack[-1][1]:
            j,t_before = stack.pop() # 栈顶找到答案了，出栈
            result[j] = i-j
        stack.append((i,t_cur)) # 能找到答案的都出栈了之后，当前气温进栈等待寻找自己的答案
    return result
```

# 496.下一个更大元素 I 



https://programmercarl.com/0496.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I.html  
- 和 [739. 每日温度](#739-每日温度) 区别：本题是需要找答案的那些元素（属于nums1）才允许放入栈
```py
def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
    
    result = [-1]*len(nums1)
    stack = [] # 存放num2中属于nums1的数字，用来寻找答案
    for i,v in enumerate(nums2):
        while stack and v > stack[-1][1]:
            j,v_before = stack.pop() 
            result[nums1.index(v_before)] = v
        if v in nums1:
            stack.append((i,v))
    return result
```

# 503.下一个更大元素II 

这道题和 739. 每日温度 几乎如出一辙，可以自己尝试做一做

https://programmercarl.com/0503.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II.html  

- 类似 [每日温度](#739-每日温度)
- 最多**只需要两轮，就可以令环中的每一个元素都作为环的起点一次，作为环的起点就意味着能够考虑到剩余所有元素和起点的比较**
- 环自增i取对应的原始下标：i%len(nums)
```py
def nextGreaterElements(self, nums: List[int]) -> List[int]:

    result = [-1]*len(nums)
    stack = []
    for i,v in enumerate(nums+nums):
        index = i%len(nums)
        while stack and v > stack[-1][1]: # 如果栈顶找到了答案
            index_before,v_before = stack.pop()
            result[index_before] = v
        stack.append((index,v))
    return result
```


