第三章 哈希表part02 

 今日任务 

● 454.四数相加II 
● 383. 赎金信 
● 15. 三数之和 
● 18. 四数之和 
● 总结  

 详细布置 

# 454.四数相加II (四个数组，返回符合条件的搭配数量)

建议：本题是 使用map 巧妙解决的问题，好好体会一下 哈希法 如何提高程序执行效率，降低时间复杂度，当然使用哈希法 会提高空间复杂度，但一般来说我们都是舍空间 换时间， 工业开发也是这样。

题目链接/文章讲解/视频讲解：https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html  

- 返回搭配的数量即可
- 前两个数组暴力遍历记录两数和及其出现次数（本题不应该去重，所以要记录和出现的次数）
- 后两个数组暴力遍历求和，查找所缺的和是否在上面的记录中出现，如果有，结果数+这个和对应的记录数
- 注意defaultdict初始化每个值为0要用lambda:0,直接写0报错。字典.get(键，不存在该键时返回的值)

# 383. 赎金信  

建议：本题 和 242.有效的字母异位词 是一个思路 ，算是拓展题 

题目链接/文章讲解：https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html 

- 注意题意是从杂志上剪下来贴成赎金信，杂志上单个字母只能用一次，比如2个a就只能用2次在赎金信里

##  Counter()相减
- 场景1：完全覆盖
Counter(a=5) - Counter(a=3)  → Counter({'a':2})

- 场景2：负值过滤
Counter(a=2) - Counter(a=5)  → 空Counter（因2-5=-3≤0）

- 场景3：多键混合
Counter(a=4, b=1) - Counter(a=1, c=2)  → Counter({'a':3, 'b':1})  （c键被忽略）

- 杂志-赎金信：赎金信有、杂志无的字母会自动过滤掉，不符合要求
- 赎金信-杂志：结果为空说明赎金信每个字母出现次数<=杂志中这个字母的出现次数、用不上的字母也自动过滤掉，满足条件；结果非空：不满足条件

## count()
- all()和any():0数值也会被视为False
- all([])为True，any([])为False

# 15. 三数之和 

建议：本题虽然和 两数之和 很像，也能用哈希法，但用哈希法会很麻烦，双指针法才是正解，可以先看视频理解一下 双指针法的思路，文章中讲解的，没问题 哈希法很麻烦。 

题目链接/文章讲解/视频讲解：https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html 

- 排序原数组方便{去重、指针移动
- 外层循环遍历每一个数作为a，内层设置双指针指向a后一个数、最后一个数，三数和大于0，右指针左移，小于0则左指针右移，等于零则添加答案
- 去重：如果当前a==上一个a，当前a得到的所有符合条件的结果都曾出现上一个a的结果中，所以当前a这一轮跳过。b、c的去重可以用while，因为不受for控制
- 注意只有当下标合法```j<k```时才进行运算以及j、k的变动

```Python
def threeSum(self, nums: List[int]) -> List[List[int]]:
    nums.sort() #无返回原地修改
    result = []
    n = len(nums)

    for i in range(n-2): # 超时，改为n-2
        j,k = i+1,n-1 # 左右指针
        x = nums[i]
        # 考虑特殊情况
        if i>0 and x ==nums[i-1]: # 对a去重（不能用while连续去重，因为i由for控制）
            continue
        if x + nums[i+1] + nums[i+2] > 0: # 该a轮次最小和都>0，那之后所有a轮次都会>0,直接跳出循环
            break
        if x + nums[n-2] + nums[n-1] < 0: # 该a轮次最大和<0,该a轮次跳过
            continue

        # 当下标合法才进行操作
        while j < k:
            sum  =x + nums[j] + nums[k]
            if sum > 0: k -= 1 # 和大了，右指针左移
            elif sum < 0: j += 1 # 和小了，左指针右移
            else: # 和为0，记录完之后，左右指针都要移动（目前和为0，一方变大，另一方要同时变小）
                result.append([x,nums[j],nums[k]])
                while j<k and nums[j] == nums[j+1]: # 对(连续)相同的b去重
                    j += 1
                j += 1
                while j<k and nums[k] == nums[k-1]:
                    k -= 1
                k -= 1
    return result
```

# 18. 四数之和  

建议： 要比较一下，本题和 454.四数相加II 的区别，为什么 454.四数相加II 会简单很多，这个想明白了，对本题理解就深刻了。 本题 思路整体和 三数之和一样的，都是双指针，但写的时候 有很多小细节，需要注意，建议先看视频。 

题目链接/文章讲解/视频讲解：https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html 
















