第九章 动态规划part10

# 300.最长递增子序列 

今天开始正式子序列系列，本题是比较简单的，感受感受一下子序列题目的思路。 
视频讲解：https://www.bilibili.com/video/BV1ng411J7xP
https://programmercarl.com/0300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html

- 注意题意歧义：这里的子序列是指可以删除元素的子序列
- dp[i]: **以i数结尾的**、最长严格递增子序列长度（注意，是以i数结尾也就是说这时候子序列最大值就是i数，不是考虑i数在内的意思）
- 递推：遍历每一个i数，对于每一个i数，再从0遍历到i-1，不断更新dp[i]。如果内层遍历的那个数小于i数，说明dp[i]至少是在dp[j]的基础上加一，为了在每一轮i中取到最大的,dp[i] = max(dp[i],dp[j]+1)；如果内层遍历的那个数大于等于i数，说明**i数做不了dp[j]对应子序列的尾数**，dp[i]不更新

```py 
def lengthOfLIS(self, nums: List[int]) -> int:
    
    longest_asc = [1]*len(nums)
    for i in range(1,len(nums)):
        for j in range(0,i):
            if nums[i] > nums[j]:
                longest_asc[i] = max(longest_asc[i],longest_asc[j]+1)
    return max(longest_asc)
```

# 674. 最长连续递增序列 

本题相对于昨天的动态规划：300.最长递增子序列 最大的区别在于“连续”。 先尝试自己做做，感受一下区别  
视频讲解：https://www.bilibili.com/video/BV1bD4y1778v
https://programmercarl.com/0674.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97.html  
- 连续
- dp[i]: **以i数结尾的**最长连续递增序列。dp[i] = dp[i-1]+1 if nums[i] > nums[i-1] else 0,一旦没有大于前面的就重置为1
- "零维"递推，就是直接用一个数值变量更新

```py
def findLengthOfLCIS(self, nums: List[int]) -> int:
    # 初始化
    longest_asc = 1
    result = 1
    # 递推
    for i in range(1,len(nums)):
        longest_asc = longest_asc+1 if (nums[i] > nums[i-1]) else 1
        result = max(result,longest_asc)
    return result 
```
# 718. 最长重复子数组 

稍有难度，要使用二维dp数组了
视频讲解：https://www.bilibili.com/video/BV178411H7hV
https://programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html

- dp[i][j]:对于 A[:i+1]与B[:j+1],**以i数和j数作为公共子数组尾数时的**最长重复子数组长度
- 递推：对于每一个i，都从头遍历一遍j，如果i数和j数相同，dp[i][j]等于当前A、B子串的前一位子串的最长公共长度+1；如果不相等，dp[i][j]直接清零（不操作，初始化就是0了）
- 因为是二维列表，不能直接输出max，所以在遍历的时候记录最大值
- 注意：result初始化要带上第一行最大值和第一列最大值

```py
def findLength(self, nums1: List[int], nums2: List[int]) -> int:

    longest_rep = [[0]*len(nums2) for _ in range(len(nums1))]
    # 第一行第一列初始化
    longest_rep[0] = [1 if i == nums1[0] else 0 for i in nums2 ]
    for i in range(len(nums1)):
        longest_rep[i][0] = 1 if nums1[i] == nums2[0] else 0

    # 递推从1,1开始，结果漏掉第一行第一列中的最大值，所以result初始化的时候要补上
    result = max(max(longest_rep[0]),max([i[0] for i in longest_rep])) 
    # 递推
    for i in range(1,len(nums1)):
        for j in range(1,len(nums2)):
            if nums1[i] == nums2[j]:
                longest_rep[i][j] = longest_rep[i-1][j-1] + 1
            result = max(result,longest_rep[i][j])
    return result
```

