第九章 动态规划part01


今天正式开始动态规划！

 理论基础 

无论大家之前对动态规划学到什么程度，一定要先看 我讲的 动态规划理论基础。 

如果没做过动态规划的题目，看我讲的理论基础，会有感觉 是不是简单题想复杂了？ 

其实并没有，我讲的理论基础内容，在动规章节所有题目都有运用，所以很重要！  

如果做过动态规划题目的录友，看我的理论基础 就会感同身受了。

https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html 
视频：https://www.bilibili.com/video/BV13Q4y197Wg  

# 509. 斐波那契数 

很简单的动规入门题，但简单题使用来掌握方法论的，还是要有动规五部曲来分析。

https://programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html  
视频：https://www.bilibili.com/video/BV1f5411K7mo  

- 直接把指定长度（n+1，因为要放一个f(0) ）的数组做出来，n是下标，f（n）是函数值

# 70. 爬楼梯   

本题大家先自己想一想， 之后会发现，和 斐波那契数 有点关系。

https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html  
视频：https://www.bilibili.com/video/BV17h411h7UH  

- 上n-1层楼有f（n-1）个方法，同理n-2楼有f（n-2）个方法。
- 上n楼可以是**在n-1楼往上跨一步**，n-1楼的每个方法都加上1步就到n楼了，总共还是f（n-1）种方法；也可以是**在n-2楼跨两步**，n-2楼的每个方法都加上2步就到n楼了，总共还是f（n-2）种方法（**不能是在n-2楼跨一步再跨一步**，这样相当于先去n-1楼，已经在f（n-1）里算过了）
- 递推公式：f（n）= f（n-2）*1 + f（n-1）*1

# 746. 使用最小花费爬楼梯 

这道题目力扣改了题目描述了，现在的题目描述清晰很多，相当于明确说 第一步是不用花费的。 

更改题目描述之后，相当于是 文章中 「拓展」的解法 

https://programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html   
视频讲解：https://www.bilibili.com/video/BV16G411c7yZ 

- 理解题意：你可以站在下标0或者下标1处开始跳跃，每次**离开当前下标都要付出对应费用**，可以跳去下一个或者下两个位置。**跳到列表外面才算是到顶楼**
- **f（i）是跳到下标i所需要的最小花费**，则问题变成求f（len(cost)）。f（0）=f（1）=0，f（2）= min（cost[0],cost[1]）
- 跳到i（i是列表外的终点下标：len（cost））有两种跳法：①从i-1的地方过去，总花费f（i-1）+cost[i-1]。
②从i-2的地方过去，总花费f（i-2）+cost[i-2]。
- f（i）= min（f（i-1）+cost[i-1]，f（i-2）+cost[i-2]）
```Python
def minCostClimbingStairs(self, cost: List[int]) -> int:

    least_cost = [0] * (len(cost)+1) # 要求的是least_cost[len(cost)]
    least_cost[0],least_cost[1] = 0,0
    least_cost[2] = min(cost[0],cost[1])
    for i in range(3,len(cost)+1):
        least_cost[i] = min(least_cost[i-1]+cost[i-1], least_cost[i-2]+cost[i-2])
    return least_cost[len(cost)]
```