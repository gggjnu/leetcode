第七章 回溯算法part03



# 93.复原IP地址  

本期本来是很有难度的，不过 大家做完 分割回文串 之后，本题就容易很多了 

题目链接/文章讲解：https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html  
视频讲解：https://www.bilibili.com/video/BV1XP4y1U73i/
- 框架类似切割成回文字符串
- 注意：每一段字符串不超过3个数字，所以下标i循环的终止是起始位置+3和len（s）的较小。题目说明s全为数字所以不需要判断出现非数字的情况
- 第一层：起始位置是0，在（0,3）位置范围内切割，切割左侧子串如果符合要求，则收集进入path，计入下一层
- 第二层：上一层的i决定了下一层的起始位置，是第一层切割位置+1，在（？，？+3），s[？:i+1]如果符合要求，则收集进入path，计入下一层
- 终止条件：起始位置==len（s）且path收集了四个子串，说明最后一个字符都处理了
- 剪枝：如果path子串大于四个，return跳到上一层
```Python
def restoreIpAddresses(self, s: str) -> List[str]:

    def is_valid(substr):
        if substr[0] == '0' and len(substr) != 1:
            return False
        return 0 <= int(substr) <= 255 
    
    def backtrack(s,index,path,result):
        # 终止
        if index == len(s) and len(path) == 4:
            result.append('.'.join(path))
            return
        # 剪枝
        if len(path) > 4:
            return 
        for i in range(index,min(len(s),index+3)):
            substr = s[index:i+1]
            if is_valid(substr):
                path.append(substr)
                backtrack(s,i+1,path,result)
                path.pop()
    path = []
    result = []
    index = 0
    backtrack(s,index,path,result)
    return result
```

# 78.子集  

子集问题，就是收集树形结构中，每一个节点的结果。 整体代码其实和 回溯模板都是差不多的。 

题目链接/文章讲解：https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html  
视频讲解：https://www.bilibili.com/video/BV1U84y1q7Ci 

- 是回溯算法的经典例题
- 求所有子集：收集每一个节点的path。求所有（满足条件）的所有组合：收集满足条件时的path。
- **在最后的result中手动添加空集**

```Python
def subsets(self, nums: List[int]) -> List[List[int]]:
    
    def backtrack(nums,index,path,result):
        if index == len(nums):
            return
        for i in range(index,len(nums)):
            path.append(nums[i])
            result.append(path[:]) # path每添加一个元素，result都收集一次这个新的path
            backtrack(nums,i+1,path,result)
            path.pop()
    path = []
    result = []
    index = 0 
    backtrack(nums,index,path,result)
    result.append([])
    return result
```

# 90.子集II 

大家之前做了 40.组合总和II 和 78.子集 ，本题就是这两道题目的结合，建议自己独立做一做，本题涉及的知识，之前都讲过，没有新内容。 

题目链接/文章讲解：https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html   
视频讲解：https://www.bilibili.com/video/BV1vm4y1F71J


- 逻辑和[78.](#78子集)类似。但由于nums存在重复元素，但结果的组合之间不能重复，所以需要在原基础上剪枝
- 需要对结果去重的，都把原始列表排序
- 剪枝和40.[查看7月日志](./0731回溯.md)类似。同一层内，如果当i元素和前一个元素i-1是相同的，因为前一个i-1节点下面的过程和i节点一模一样，会导致一模一样的重复，所以就直接跳过i节点（continue），直接开启同层下一轮（也就是同层下一个节点）。层内第一个节点（i==index）是要有的，即使这个节点对应的元素和它前一位元素相同也不需要剪枝，因为是不同层所以不影响



```Python
def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
   
    def backtrack(nums,index,path,result):

        for i in range(index,len(nums)):
            # 剪枝
            if i > index and nums[i] == nums[i-1]:
                continue

            path.append(nums[i])
            result.append(path[:])
            backtrack(nums,i+1, path,result)
            path.pop()
    path = []
    result = []
    index = 0
    nums = sorted(nums) # 需要对结果去重的都把原始列表排序
    backtrack(nums,index,path,result)
    result.append([])
    return result
```

