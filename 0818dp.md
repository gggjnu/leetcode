第九章 动态规划part08

 股票问题是一个动态规划的系列问题，前两题并不难，第三题有难度。

# 121. 买卖股票的最佳时机 
视频讲解：https://www.bilibili.com/video/BV1Xe4y1u77q
https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html

- 注意：只能买卖一次
- 暴力超时
- 遍历记录最小，实时更新当前数-最小，总有一轮会遇上后续最大-前面最小的情况
```py
def maxProfit(self, prices: List[int]) -> int:
    # 贪心
    # 有效答案必须是左边小右边大的两个数之差。因为是从左往右遍历，所以会先看到这个较小数，记录历史最小，再用右边的数减去这个数，总有一次能达到最大。
    result = 0
    min_num = float('inf')
    for i in range(len(prices)):
        min_num = min(min_num,prices[i])
        result = max(result,prices[i]-min_num)
    return result
```

# 122.买卖股票的最佳时机II  
视频讲解：https://www.bilibili.com/video/BV1D24y1Q7Ls
https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html  

- 不限制买卖次数，收集所有的正相邻收益

# 123.买卖股票的最佳时机III  

这道题一下子就难度上来了，关键在于至多买卖两次，这意味着可以买卖一次，可以买卖两次，也可以不买卖。
视频讲解：https://www.bilibili.com/video/BV1WG411K7AR
https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html
- 动态规划
- dp[i][j]: 到i天时，这个股票处于j买卖状态的话，所能带来的最大受益。j有5种状态（0：初始状态，1：第一次买入持有状态，2：第一次卖出持空状态，3第二次买入持有状态，4第二次卖出持空状态）
- 递推：dp[i][0]只能从dp[i-1][0]过来。dp[i][1]要么是dp[i-1][0]转变过来的，收益是dp[i-1][0]-prices[i],要么是dp[i-1][1]延续过来的。以此类推
- 最后取dp[-1]的最大值即可

```Py
def maxProfit(self, prices: List[int]) -> int:

    # 初始化
    max_profit = [0]*5 # 一维递推，5个状态
    max_profit[1],max_profit[3] = -prices[0],-prices[0]
    # 一维递推。为什么顺序递推不怕覆盖：不能倒序遍历未来的日子，且状态0-4是按实际买卖逻辑排序的，本轮次的更新要么是上一轮沿袭要么是踩着本轮最新的前面状态过来
    for i in range(1,len(prices)):
        max_profit[0] = max_profit[0]
        max_profit[1] = max(max_profit[0]-prices[i],max_profit[1])
        max_profit[2] = max(max_profit[1]+prices[i],max_profit[2])
        max_profit[3] = max(max_profit[2]-prices[i],max_profit[3])
        max_profit[4] = max(max_profit[3]+prices[i],max_profit[4])
    return max(max_profit)
        
```



