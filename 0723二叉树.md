第六章  二叉树part03


迭代法，大家可以直接过，二刷有精力的时候 再去掌握迭代法。


# 110.平衡二叉树 （优先掌握递归）

再一次涉及到，什么是高度，什么是深度，可以巩固一下。

题目链接/文章讲解/视频讲解：https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html  

## 递归
- 基于返回节点高度的递归函数
- 求高度，左右中后序
- 入参和出参：节点和高度（只要有一轮出现非平衡，都返回-1）
- 终止：节点为空（遍历到了叶子结点的子节点），高度为0
- 单层逻辑：如果任一子树有非平衡的直接返回-1，如果左子树和右子树高度相差大于1则非平衡直接返回-1，如果平衡则返回当前节点高度（左右子树较高高度+1）
```Python
def isBalanced(self, root: Optional[TreeNode]) -> bool:
    
    def getheight(node):
        if not node:
            return 0
        leftheight = getheight(node.left)
        rightheight = getheight(node.right)
        if abs(leftheight - rightheight)>1 or leftheight == -1 or rightheight == -1: 
            return -1
        else:
            return max(leftheight,rightheight) + 1
    
    return getheight(root) != -1
```


# 257. 二叉树的所有路径 （优先掌握递归）  

类似题目：112、113

这是大家第一次接触到回溯的过程， 我在视频里重点讲解了 本题为什么要有回溯，已经回溯的过程。 

如果对回溯 似懂非懂，没关系， 可以先有个印象。 

题目链接/文章讲解/视频讲解：https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html 

## 递归
- path记录当前路径，result收集路径
- 先把当前节点加入path，判断当前节点是叶子则resul收集，如果有左节点则开启新一轮，如果有右节点则开启新一轮。新一轮的参数要在path后面+'->'连接节点

```Python
def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
    # 递归
    
    def traversepath(node,path,result):
        path += str(node.val) # 路径添加当前节点
        if not node.left and not node.right:
            result.append(path)
        if node.left:
            traversepath(node.left,path + '->',result)
        if node.right:
            traversepath(node.right,path + '->',result)

    path = ''
    result = []
    traversepath(root,path,result)
    return result
```
## 迭代
- 每次入队一个元祖（节点，没有添加这个节点的路径字符串）
- 注意不能直接把原路径字符串path加上节点之后直接path传入下一轮，因为会导致叶节点之后继续加其他节点。需要新建new_path对象存放添加当前节点的最新路径，再传给下一轮
```Python
def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
    # 迭代
    if not root: return []
    
    result = [] # 收集结果
    que = deque()
    que.append((root,""))
    while que:
        cur,path = que.popleft()
        new_path = path + str(cur.val) # 新建添加当前节点的路径变量，防止叶节点之后继续添加
        # 当前节点是叶子节点
        if not cur.left and not cur.right:
            result.append(new_path)
        if cur.left:
            que.append((cur.left,new_path+'->'))
        if cur.right:
            que.append((cur.right,new_path+'->'))
    return result
```

# 404.左叶子之和 （优先掌握递归）

其实本题有点文字游戏，搞清楚什么是左叶子，剩下的就是二叉树的基本操作。 

题目链接/文章讲解/视频讲解：https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html

## 递归
```Python
def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
    # 迭代
    # 首先要确定叶子的定义：没有子节点
    # 如何确定当前节点是左叶子：当前节点是上一轮的node.left,且是子节点
    # 全部左子节点和=左子树左子节点和+右子树左子节点和
    def is_leftleave(root):
        if root is None:
            return 0
        leftValue = 0 # 第一轮初始化总和为0，在递归过程中会累加
        # 如果是左子节点，则本轮左子节点值更新
        if root.left is not None and root.left.left is None and root.left.right is None:
            leftValue = root.left.val
        # 累加（式子左侧leftValue值不受右侧递归函数内的leftValue重置更新影响）
        leftValue += is_leftleave(root.left) + is_leftleave(root.right)
        return leftValue
    
    return is_leftleave(root)
```




# 222.完全二叉树的节点个数（优先掌握递归）

需要了解，普通二叉树 怎么求，完全二叉树又怎么求

题目链接/文章讲解/视频讲解：https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html  
## 递归
- 不能直接套用输出遍历列表result的递归模板，因为把传参result改为整数cnt的话，cnt是不可变变量，内部+1不传递给外部的cnt
```Python
def countNodes(self, root: Optional[TreeNode]) -> int:
    # 递归
    def traverse(node):
        if not node:
            return 0
        cnt = 1
        cnt += traverse(node.left) + traverse(node.right)
        return cnt
    
    return traverse(root)
```

