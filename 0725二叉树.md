第六章 二叉树 part05


 详细布置 

# 654.最大二叉树 

又是构造二叉树，昨天大家刚刚做完 中序后序确定二叉树，今天做这个 应该会容易一些， 先看视频，好好体会一下 为什么构造二叉树都是 前序遍历 

题目链接/文章讲解：https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html  
视频讲解：https://www.bilibili.com/video/BV1MG411G7ox  

# 617.合并二叉树 

这次是一起操作两个二叉树了， 估计大家也没一起操作过两个二叉树，也不知道该如何一起操作，可以看视频先理解一下。 优先掌握递归。

题目链接/文章讲解：https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html  
视频讲解：https://www.bilibili.com/video/BV1m14y1Y7JK  

- 直接修改第一棵树的节点：同时入参两棵树的两个节点，如果有一方节点为空返回另一方节点，如果都不为空则修改树1节点并且开启左右子树的迭代
    

```Python
def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
    # 递归
    # 如果有一侧有空节点
    if not root1:
        return root2
    if not root2:
        return root1
    # 如果都非空
    root1.val = root1.val + root2.val
    root1.left = self.mergeTrees(root1.left,root2.left)
    root1.right = self.mergeTrees(root1.right,root2.right)

    return root1
```

# 700.二叉搜索树中的搜索 

递归和迭代 都可以掌握以下，因为本题比较简单， 了解一下 二叉搜索树的特性

题目链接/文章讲解: https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html  
视频讲解：https://www.bilibili.com/video/BV1wG411g7sF   

## 递归
- 二叉搜索树和普通二叉树的却别：子节点小于父节点、左节点小于右节点。所以遍历的时候可以选择一个方向，return这个方向的结果即可
- 注意要把val传进去
```Python
def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
    # 递归

    if not root or root.val == val:
        return root
    if root.val < val:
        return self.searchBST(root.right,val)
    if root.val > val:
        return self.searchBST(root.left,val)
```

## 迭代
- 因为二叉搜索树没有重复节点且有序，所以如果当前节点大于目标则下一个节点为左子节点，否则反之，如果等于则返回当前节点，如果是空则也返回当前节点（空）
```Python
 def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
    # 迭代

    cur = root
    while cur:
        if cur.val > val:
            cur = cur.left
        elif cur.val < val:
            cur = cur.right
        else:# 相等或者为空
            return cur
```

        

# 98.验证二叉搜索树 

遇到 **搜索树，一定想着中序遍历**，这样才能利用上特性。 

但本题是有陷阱的，可以自己先做一做，然后在看题解，看看自己是不是掉陷阱里了。这样理解的更深刻。

题目链接/文章讲解：https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html 
视频讲解：https://www.bilibili.com/video/BV18P411n7Q4  

- 中序遍历应该是递增的序列，在根节点处比较大小，如果出现当前节点小于等于前一个节点的返回False

```Python
class Solution:
    def __init__(self):
        # 递归函数外初始化一个不断更新记录上一个节点的maxval
        self.maxval = float('-inf')
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        # 递归
        
        if not root: return True
        #左
        left =  self.isValidBST(root.left)
        #中，判断
        if root.val <= self.maxval:
            return False
        else:
            self. maxval = root.val
        # 右
        right = self.isValidBST(root.right)
        return left and right
```

