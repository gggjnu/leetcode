第六章 二叉树part08

# 669. 修剪二叉搜索树 

这道题目比较难，比 添加增加和删除节点难的多，建议先看视频理解。

题目链接/文章讲解： https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html  
视频讲解： https://www.bilibili.com/video/BV17P41177ud  
- 搜边和全搜的结合，找到边界后只需要处理单边即可，整体需要都过全搜来找到边界节点、修改或保留节点
- 若节点小于左边界则返回节点右子树合适范围内的节点来代替自己（在上一层的.left=或者.right=中完成代替操作）
- 若节点大于右边界则返回节点左子树合适范围内的节点来代替自己（在上一层的.left=或者.right=中完成代替操作）
```Python
def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:
    # 递归
    if not root: return root
    # 如果找到需要被替换的范围外节点
    if root.val < low:
        return self.trimBST(root.right,low,high)
    if root.val > high:
        return self.trimBST(root.left,low,high)
    # 遍历+替换操作
    root.left = self.trimBST(root.left,low,high)
    root.right = self.trimBST(root.right,low,high)
    # 向上一层返回本层处理好的（或者是无需处理的原节点）子树根节点
    return root
```


# 108.将有序数组转换为二叉搜索树  

本题就简单一些，可以尝试先自己做做。

https://programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html  
视频讲解：https://www.bilibili.com/video/BV1uR4y1X7qL  

## 递归
- 平衡二叉树，左右子树尽量一样深度，则根节点是序列的中位数，左子节点是左侧剩余序列的中位数，右子节点同理
```Python
def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
    # 递归
    
    if not nums: return None
    index = len(nums)//2
    node = TreeNode(nums[index])
    node.left = self.sortedArrayToBST(nums[:index])
    node.right = self.sortedArrayToBST(nums[index+1:])
    return node
```

# 538.把二叉搜索树转换为累加树  

本题也不难，在 求二叉搜索树的最小绝对差 和 众数 那两道题目 都讲过了 双指针法，思路是一样的。

https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html  
视频讲解：https://www.bilibili.com/video/BV1d44y1f7wP

- 比自身大的节点都在右子树上，使用右中左遍历。
- 函数外建立pre记录上一个节点(累加后)的值。**pre是不可变变量，需要按逻辑顺序被修改**，所以需要设为类成员变量用于实时更新
```Python
class Solution:
    def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        # 递归
        self.pre = 0
        self.convert(root)
        return root

    def convert(self,root):
        if not root: return 
        # 右
        self.convert(root.right)
        # 中
        root.val += self.pre
        self.pre = root.val
        # 左
        self.convert(root.left)
```
 
总结篇  

好了，二叉树大家就这样刷完了，做一个总结吧

https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html   




