第六章 二叉树part07


# 235. 二叉搜索树的最近公共祖先 

相对于 二叉树的最近公共祖先 本题就简单一些了，因为 可以利用二叉搜索树的特性。 

题目链接/文章讲解：https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html  
视频讲解：https://www.bilibili.com/video/BV1Zt4y1F7ww  
## 递归
- 和普通二叉树的区别是，可以选定某一个方向return，而不考虑每个节点处的左右结果

```Python
def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
    # 递归
    # 前序

    # if not root: return root
    # if root.val == p.val or root.val == q.val:
    #     return root
    # if p.val < root.val < q.val or  q.val < root.val < p.val:
    #     return root
    # 以上可以统一return root

    if root.val > p.val and root.val > q.val:
            return self.lowestCommonAncestor(root.left,p,q)
    if root.val < p.val and root.val < q.val:
            return self.lowestCommonAncestor(root.right,p,q)
    else:
        return root
```
## 迭代
```Python
def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
    # 迭代
    cur = root
    while cur:
        if cur.val < p.val and cur.val < q.val:
            cur = cur.right
        elif  cur.val > p.val and cur.val > q.val:
            cur = cur.left
        else:
            return cur
```
# 701.二叉搜索树中的插入操作  

本题比想象中的简单，大家可以先自己想一想应该怎么做，然后看视频讲解，就发现 本题为什么比较简单了。

题目链接/文章讲解：https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html  
视频讲解：https://www.bilibili.com/video/BV1Et4y1c78Y  
## 递归
- 二叉搜索树插入节点统一在**含有空子节点的节点**下插入，不需要重构
- 自下而上，假设当前节点是空节点：新建新节点，如果新节点大于上层节点则作为右子节点，否则作为左子节点。结束后返回当前节点（每一层都返回当前节点，那么第一层返回的还是根节点）
```Python
    
    # 如果是空节点
    if not root:
        node = TreeNode(val)
        return node # 返回给上一层被插入的节点轮
    # 如果非空
    if root.val > val:
        root.left = self.insertIntoBST(root.left,val)
    else:
        root.right = self.insertIntoBST(root.right,val)
    
    # 向上层不断返回当前节点，最终返回根节点
    return root
```
## 迭代
- 先寻找一个合适的有空节点的节点cur
```Python
def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
    
    if not root: return TreeNode(val)
    
    cur = root
    while cur:
        parent = cur # 更新当前节点，最终为被插入子节点的父节点
        # 迭代
        if cur.val > val:
            cur = cur.left
        elif cur.val < val:
            cur = cur.right
    if parent.val < val:
        parent.right = TreeNode(val)
    else:
        parent.left = TreeNode(val)
    return root
```


# 450.删除二叉搜索树中的节点  

相对于 插入操作，本题就有难度了，涉及到改树的结构 

题目链接/文章讲解：https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html  
视频讲解：https://www.bilibili.com/video/BV1tP41177us 
## 递归
- 找到被删除节点：1.节点没有子节点返回None补位2.左子为空，右子树补位3.右子为空，左子树补位4.左右都有，左子树整体小于右子树，所以把左子树接到右子树的最小节点（最左节点）的左侧,返回右子树
- 没找到被删除节点：返回None
- 操作结束后返回当前节点
```Python
def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
    # 递归（前序）
    
    if not root: return root

    if root.val == key:
        # 2.3.（包括了1.双侧都空返回None的情况）
        if not root.left: return root.right
        elif not root.right: return root.left
        # 4.
        else:
            cur = root.right # 找右子树的最左（小）节点
            while cur.left:
                cur = cur.left
            cur.left = root.left
            return root.right
    if root.val > key: root.left = self.deleteNode(root.left,key)
    if root.val < key: root.right = self.deleteNode(root.right,key)
    return root # 向外层返回当前节点，最外层的返回是根节点
```


