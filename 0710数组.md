# 209.长度最小的子数组

题目建议： 本题关键在于理解滑动窗口，这个滑动窗口看文字讲解 还挺难理解的，建议大家先看视频讲解。  拓展题目可以先不做。 

题目链接：https://leetcode.cn/problems/minimum-size-subarray-sum/
文章讲解：https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html
视频讲解：https://www.bilibili.com/video/BV1tZ4y1q7XE

* 滑窗法的sum在循环外初始，之后不再初始化。暴力法的sum在每次外层循环中都初始化为0
* 滑窗法，只有在满足条件时才更新min_len、缩短窗口


# 59.螺旋矩阵II

题目建议：  本题关键还是在转圈的逻辑，在二分搜索中提到的区间定义，在这里又用上了。 

题目链接：https://leetcode.cn/problems/spiral-matrix-ii/
文章讲解：https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html
视频讲解：https://www.bilibili.com/video/BV1SL4y1N7mV/

* 四个边界往中间收缩，考虑top收缩到等于bottom时还有数字没有写进去，所以应该取等号

# 区间和
前缀和是一种思维巧妙很实用 而且 很有容易理解的一种算法思想，大家可以体会一下

文章讲解：https://www.programmercarl.com/kamacoder/0058.%E5%8C%BA%E9%97%B4%E5%92%8C.html

* 不需要使用index去读取数据，因为n确定了长度，也能用输入总长度求得边界组数。注意split之后的列表是字符串列表，要转为int
```
import sys
input = sys.stdin.read()

def cal_section_sum():
    data = input.split() # 装单个输入的列表
    data = [int(i) for i in data]
    n = data[0] # 数据长度
    nums = data[1:n+1] # 数据列表

    boundaries={} # 区间字典
    bs_cnt = (len(data)-(n+1)) 
    for i in range(0,bs_cnt,2):
        boundaries[i] = data[n+1+i:n+1+(i+2)]
    
    cum_sum_list = [] # 前缀和列表
    cum_sum = 0
    for i in range(n):
        cum_sum += nums[i]
        cum_sum_list.append(cum_sum)

    for k,v in boundaries.items():
        # 如果区间起始为0，不存在前一位的前缀和，单独处理
        if v[0] == 0: 
            print(cum_sum_list[v[1]])
        # 区间和=右索引前缀和-左索引前一个索引的前缀和
        else:
            print(cum_sum_list[v[1]]-cum_sum_list[v[0]-1])

if __name__ == '__main__':
    cal_section_sum()

```
 
# 开发商购买土地
https://www.programmercarl.com/kamacoder/0044.%E5%BC%80%E5%8F%91%E5%95%86%E8%B4%AD%E4%B9%B0%E5%9C%9F%E5%9C%B0.html
总结 

题目建议：希望大家 也做一个自己 对数组专题的总结

文章链接：https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html 

* 先分开求横向行前缀和、纵向列前缀和，再求横向分割差、纵向分割差（简化公式：b公司-a公司=（总和-a公司）-a公司=总和-2*a公司），注意差要用绝对值
* 注意list类型的二维列表，不能用np.ndarray的a[row,col]的切片方式，要使用列表解析式[mat[row][col] for row in range(m)]
* acm模式下要print，retrun变量无法识别为输出
```
import sys
input = sys.stdin.read()

def find_min_diff():
    data = [int(i) for i in input.split()] # 处理输入
    m,n = data[0],data[1]

    mat = [[0]*n for _ in range(m)] # 土地二维数组
    index = 2
    for i in range(m):
        for j in range(n):
            mat[i][j] = data[index]
            index += 1

    # 计算行前缀和
    horizontal_cumsum = []
    cumsum = 0
    for row in range(m):
        cumsum += sum([mat[row][col] for col in range(n)])
        horizontal_cumsum.append(cumsum)

    # 计算列前缀和
    vertical_cumsum = []
    cumsum = 0
    for col in range(n):
        cumsum += sum([mat[row][col] for row in range(m)])
        vertical_cumsum.append(cumsum)

    # 计算最小差距,b公司-a公司=（总和-a公司）-a公司=总和-2*a公司
    min_diff = float('inf')

    for row in range(m-1):
        min_diff = min(min_diff, abs(horizontal_cumsum[-1] - 2*horizontal_cumsum[row]))

    for col in range(n-1):
        min_diff = min(min_diff, abs(vertical_cumsum[-1] - 2*vertical_cumsum[col]))
    
    print(min_diff) 

if __name__ == '__main__':
    find_min_diff()

```
