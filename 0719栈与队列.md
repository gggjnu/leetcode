第五章 栈与队列part02

 
# 150. 逆波兰表达式求值 

本题不难，但第一次做的话，会很难想到，所以先看视频，了解思路再去做题 

题目链接/文章讲解/视频讲解：https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html  

- 逆波兰表达式：数字、数字、运算符这三个组成的结果整体作为一个数字，依次类推
- 就近匹配，用栈
- 注意：//是向下取整（精确结果整数部分-1，当精确结果是负数时，不是向0截断），int()是取整数部分，满足向0截断。注意除法减法的运算顺序

```Python
def evalRPN(self, tokens: List[str]) -> int:
    
    stack = []
    opr = "+-*/"
    for i in tokens:
        if i in opr:
            b = int(stack.pop())
            a = int(stack.pop())
            print(f'b={b}')
            print(f'a={a}')
            if i == opr[0]:
                stack.append(a+b)
                print(f'{a+b}')

            elif i == opr[1]:
                stack.append(a-b)
                print(f'{a-b}')

            elif i == opr[2]:
                stack.append(a*b)
                print(f'{a*b}')

            else:
                stack.append(int(a/b))
                print(f'{int(a/b)}')

        else:
            stack.append(i)
```
# 239. 滑动窗口最大值 （有点难度，可能代码写不出来，但一刷至少需要理解思路）

之前讲的都是栈的应用，这次该是队列的应用了。

本题算比较有难度的，需要自己去构造单调队列，建议先看视频来理解。 

题目链接/文章讲解/视频讲解：https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html 

- 因为每次滑动有大部分的数子是重复的，所以额外使用一个双头队列记录这些重复部分的**有潜力**成为下一轮最大值的**所有**备选数字（降序排列），这样窗内遍历k次降为和k无关的判断。队列并且随滑动窗口新增（减少）数字而更新
- 双头队列：（双头的意思是头尾都有内置的操作方法）双头队列的更新：如果为空，放入当前数字；如果非空，如果当前数字比队尾大就一直代替队尾，如果当前数字比队尾小**或者等于队尾**就放入当前数字(队列中要保留相等的数字，否则出窗一个该数字，后续的都没有记录了)
- 双头队列的效果：前k个数字构建队列，队头是当前滑窗的最大值，队列保持非增。下一步进入下一个滑窗，如果出窗数字是队头（这一步最大值）则出队头，然后按规则更新队列。**注意要先考虑是否剔除队头、再添加结果，否则有可能添加的是本轮出窗的那个上轮最大值**


```Python
def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        
        result = []
        que = deque()
        for i in range(len(nums)):
            # 构建队列
            while que and nums[i] > que[-1]:
                que.pop()
            que.append(nums[i])
            
            # 第二个窗口开始以及之后，判断出窗数字是否等于队列队头
            if i >= k and nums[i-k] == que[0]:
                que.popleft()

            # 第一个窗口遍历完成以及之后，获取结果
            if i >= k-1:
                result.append(que[0])
        return result
```

# 347.前 K 个高频元素  （有点难度，可能代码写不出来，一刷至少需要理解思路）

大/小顶堆的应用， 在C++中就是优先级队列 

本题是 大数据中取前k值 的经典思路，了解想法之后，不算难。

题目链接/文章讲解/视频讲解：https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html  

## 字典法

- 先构造{数字：频率}，再构造{频率：[数字1，数字2，···]}用来解决多个数字有相同频率的问题
- sorted()是内置函数，无论传入是什么类型的可迭代对象，都返回列表，**传入字典则返回键的排序后列表**
- 列表.sort()是列表的内置方法，没有返回，原地修改
```Python
def topKFrequent(self, nums: List[int], k: int) -> List[int]:
    # 字典是无序的，本身无法排序
    # 相同频率的元素视为dense rank
    # 注意传参是k，局部循环变量不可以用k,v中的k

    num_cnt = Counter(nums) # {数字:频率}
    fre_num = defaultdict(list)
    for key,val in num_cnt.items():
        fre_num[val].append(key) # {频率：[数字1，数字2，···]} 
    
    frelst = sorted(fre_num) # 排序后的键列表
    result = [] 
    for fre in frelst[::-1]:
        if len(result) >= k: 
            break
        result.extend(fre_num[fre]) # 对应的数字列表逐个添加到结果中
    return result
```

## 堆
- 堆是完全二叉排序树，堆顶是最小值，左右子节点都大于根节点。
- heapq是标准库，heapq.heapify(列表)**无返回原地修改为层遍历顺序的排序树列表**(列表顺序为按层遍历)，heap.heappop(列表)原地修改并弹出堆顶，heap.heappush(列表,元素)无返回原地加入新元素
- 使用小顶堆：直接建堆counter的(v,k)，卡堆列表的元组数量k，用高频换出低频，则最终的堆列表是前k高频（fre,num）。
```Python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        
        num_cnt = Counter(nums)
        heap = []
        for num,fre in num_cnt.items():
            if len(heap) < k:
                heapq.heappush(heap,(fre,num))
            else:
                if fre > heap[0][0]: # 置换最小
                    heapq.heappush(heap,(fre,num))
                    heapq.heappop(heap)
        return [num for cnt,num in heap]
```


 总结 

栈与队列做一个总结吧，加油

https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93.html  

